* Random selection of edges

In the instruction:
"The procedure should run through all possible undirected edges, say
(i,j) and place the edge in the graph if a random probability
calculation is less than the density." 
contradicts:
"So a graph whose density is 0.1 would have 10% of its edges picked at
random and its edge distance would be selected at random from the
distance range."

The first alternative does not guarantee that the correct number of
edges be created. I implemented the second alternative instead, where
the correct number of edges are picked, it is only which ones are picked
which is random.

* int Edge::start_get(void) const
The "const" at the end of the function header applies to the "this"
pointer. This allows to call edge.start_get() in another function, even
if the edge is being declared const.
Otherwise, trying to take away the const gives a compilation error.

* control of output
iomanip contains functions to set the field width, and double precision
of iostream output.

Variable name "new_edge": no pun intended :)

* New type
"unsigned" can be used as a type. This is useful in for loops comparing to
std::vector.size(), to avoid type mismatch warnings. Leaving out the "int" in
"unsigned int" saves place and keystrokes.

* iterator
Iterators seemed obscure at first, but are easier to use than I thought. I am
not yet sure why they are better than just going of indeces, but they seem the
canonical way to deal with vectors and lists.

* list
I implemented the priority queue as a vector first, until I found the class
list. It allows to insert elements in the middle without the need to shift the
rest of the elements.
